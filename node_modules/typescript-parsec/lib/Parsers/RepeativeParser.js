"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.lrec_sc = exports.lrec = exports.list_sc = exports.list = exports.repr = exports.rep_sc = exports.rep = void 0;
var ApplyParser_1 = require("./ApplyParser");
var ParserInterface_1 = require("./ParserInterface");
var SequencialParser_1 = require("./SequencialParser");
function rep(p) {
    var reprParser = repr(p);
    return {
        parse: function (token) {
            var output = reprParser.parse(token);
            if (output.successful) {
                return {
                    candidates: output.candidates.reverse(),
                    successful: true,
                    error: output.error
                };
            }
            else {
                return output;
            }
        }
    };
}
exports.rep = rep;
function rep_sc(p) {
    return {
        parse: function (token) {
            var error;
            var result = [{ firstToken: token, nextToken: token, result: [] }];
            while (true) {
                var steps = result;
                result = [];
                for (var _i = 0, steps_1 = steps; _i < steps_1.length; _i++) {
                    var step = steps_1[_i];
                    var output = p.parse(step.nextToken);
                    error = ParserInterface_1.betterError(error, output.error);
                    if (output.successful) {
                        for (var _a = 0, _b = output.candidates; _a < _b.length; _a++) {
                            var candidate = _b[_a];
                            if (candidate.nextToken !== step.nextToken) {
                                result.push({
                                    firstToken: step.firstToken,
                                    nextToken: candidate.nextToken,
                                    result: step.result.concat([candidate.result])
                                });
                            }
                        }
                    }
                }
                if (result.length === 0) {
                    result = steps;
                    break;
                }
            }
            return ParserInterface_1.resultOrError(result, error, true);
        }
    };
}
exports.rep_sc = rep_sc;
function repr(p) {
    return {
        parse: function (token) {
            var error;
            var result = [{ firstToken: token, nextToken: token, result: [] }];
            for (var i = 0; i < result.length; i++) {
                var step = result[i];
                var output = p.parse(step.nextToken);
                error = ParserInterface_1.betterError(error, output.error);
                if (output.successful) {
                    for (var _i = 0, _a = output.candidates; _i < _a.length; _i++) {
                        var candidate = _a[_i];
                        if (candidate.nextToken !== step.nextToken) {
                            result.push({
                                firstToken: step.firstToken,
                                nextToken: candidate.nextToken,
                                result: step.result.concat([candidate.result])
                            });
                        }
                    }
                }
            }
            return ParserInterface_1.resultOrError(result, error, true);
        }
    };
}
exports.repr = repr;
function applyList(value) {
    return [value[0]].concat(value[1].map(function (pair) { return pair[1]; }));
}
function list(p, s) {
    return ApplyParser_1.apply(SequencialParser_1.seq(p, rep(SequencialParser_1.seq(s, p))), applyList);
}
exports.list = list;
function list_sc(p, s) {
    return ApplyParser_1.apply(SequencialParser_1.seq(p, rep_sc(SequencialParser_1.seq(s, p))), applyList);
}
exports.list_sc = list_sc;
function applyLrec(callback) {
    return function (value) {
        var result = value[0];
        for (var _i = 0, _a = value[1]; _i < _a.length; _i++) {
            var tail = _a[_i];
            result = callback(result, tail);
        }
        return result;
    };
}
function lrec(p, q, callback) {
    return ApplyParser_1.apply(SequencialParser_1.seq(p, rep(q)), applyLrec(callback));
}
exports.lrec = lrec;
function lrec_sc(p, q, callback) {
    return ApplyParser_1.apply(SequencialParser_1.seq(p, rep_sc(q)), applyLrec(callback));
}
exports.lrec_sc = lrec_sc;
//# sourceMappingURL=RepeativeParser.js.map